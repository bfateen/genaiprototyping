AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'Combined template for Serverless RAG Q&A application using Knowledge Base, Agents, OpenSearch Serverless'

Parameters:

  AOSSCollectionName:
    Description: Name of the Amazon OpenSearch Service Serverless (AOSS) collection.
    Default: inagent-kb
    Type: String
    MinLength: 1
    MaxLength: 21
    AllowedPattern: ^[a-z0-9](-*[a-z0-9])*
    ConstraintDescription: Must be lowercase or numbers with a length of 1-63 characters.

  AOSSIndexName:
    Description: Name of the vector index in the Amazon OpenSearch Service Serverless (AOSS) collection.
    Default: inagent-io
    Type: String

  KnowledgeBaseName:
    Default: instantagent-kb
    Type: String
    Description: The name of the knowledge base.

  KnowledgeBaseDescription:
    Default: Answer based only on information contained in knowledge base. 
    Type: String
    Description: The description of the knowledge base.

  AgentName:
    Default: instantagent1
    Type: String
    Description: The name of the agent.

Resources:

  AdminUser:
    Type: AWS::IAM::User
    Properties:
      UserName: 'leap-admin'
      Path: "/"
      

  AdminUserSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: 'leap-admin-credentials'
      GenerateSecretString:
        SecretStringTemplate: '{"username": "cf-admin-user"}'
        GenerateStringKey: "password"
        PasswordLength: 16
        ExcludeCharacters: '"@/\\'

  AdminUserAccessKey:
    Type: AWS::IAM::AccessKey
    Properties:
      UserName: !Ref AdminUser

  AdminUserPolicy:
    Type: AWS::IAM::UserPolicy
    Properties:
      UserName: !Ref AdminUser
      PolicyName: AdminAccess
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action: '*'
            Resource: '*'

  # First adding the Lambda Execution Role that was missing
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: OpenSearchServerlessAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 
                  - 'aoss:UpdateAccessPolicy'
                  - 'aoss:CreateAccessPolicy'
                  - 'aoss:GetAccessPolicy'
                  - 'aoss:BatchGetCollection'
                  - 'aoss:APIAccessAll'
                  - 'aoss:ListCollections'
                  - 'aoss:DescribeCollection'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'aoss:CreateIndex'
                  - 'aoss:UpdateIndex'
                  - 'aoss:DescribeIndex'
                  - 'aoss:ReadDocument'
                  - 'aoss:WriteDocument'
                Resource: !Sub 'arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/${AOSSCollectionName}'

  # Basic Lambda Execution Role for Delete S3 Bucket function
  LambdaBasicExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*

  S3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Description: Creates an Amazon S3 bucket to hold source data for the knowledge base.
    Properties:
      BucketName: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - !Sub ${AWS::AccountId}
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  BucketCleanupResource2:
    Type: Custom::S3Cleanup
    DependsOn: S3Bucket
    Properties:
      ServiceToken: !GetAtt S3CleanupFunction.Arn
      BucketName: !Ref S3Bucket

  AmazonBedrockExecutionRoleForKnowledgeBase:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - '-'
        - - AmazonBedrockExecutionRoleForKnowledgeBase
          - !Ref AOSSCollectionName
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - bedrock.amazonaws.com
                - aoss.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                "aws:SourceAccount": !Sub "${AWS::AccountId}"
              ArnLike:
                "AWS:SourceArn": !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: S3ReadOnlyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3-object-lambda:Get*
                  - s3-object-lambda:List*
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*
        - PolicyName: AOSSAPIAccessAll
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - aoss:APIAccessAll
                Resource: !Sub arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/*
        - PolicyName: BedrockListAndInvokeModel
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:ListCustomModels
                  - bedrock:InvokeModel
                Resource: '*'
        - PolicyName: OpenSearchServerlessAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 
                  - aoss:CreateCollection
                  - aoss:DeleteCollection
                  - aoss:CreateAccessPolicy
                  - aoss:CreateSecurityPolicy
                  - aoss:GetAccessPolicy
                  - aoss:UpdateAccessPolicy
                  - aoss:BatchGetCollection
                  - aoss:CreateIndex
                  - aoss:DeleteIndex
                  - aoss:UpdateIndex
                Resource: '*'

  Collection:
    Type: 'AWS::OpenSearchServerless::Collection'
    Properties:
      Name: !Ref AOSSCollectionName
      Type: VECTORSEARCH
      StandbyReplicas: DISABLED
      Description: Collection to hold vector search data
    DependsOn: EncryptionPolicy

  NetworkPolicy:
    Type: 'AWS::OpenSearchServerless::SecurityPolicy'
    Properties:
      Name: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - net-policy3
      Type: network
      Description: Network policy for the AOSS collection
      Policy: !Sub >-
        [{"Rules":[{"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"]}, {"ResourceType":"dashboard","Resource":["collection/${AOSSCollectionName}"]}],"AllowFromPublic":true}]

  EncryptionPolicy:
    Type: 'AWS::OpenSearchServerless::SecurityPolicy'
    Properties:
      Name: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - security-policy3
      Type: encryption
      Description: Encryption policy for the AOSS collection
      Policy: !Sub >-
        {"Rules":[{"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"]}],"AWSOwnedKey":true}

  DataAccessPolicy:
    Type: 'AWS::OpenSearchServerless::AccessPolicy'
    Properties:
      Name: 'instantagent-access-policy3'
      Type: data
      Description: Access policy for the AOSS collection
      Policy: !Sub >-
        [{"Description":"Access for cfn user","Rules":[{"ResourceType":"index","Resource":["index/${AOSSCollectionName}/*"],"Permission":[
                    "aoss:CreateIndex",
                    "aoss:UpdateIndex",
                    "aoss:DescribeIndex",
                    "aoss:ReadDocument",
                    "aoss:WriteDocument"
                  ]},
        {"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"],"Permission":["aoss:*"]}],
        "Principal":["${AdminUser.Arn}", "${AmazonBedrockExecutionRoleForKnowledgeBase.Arn}", "${LambdaExecutionRole.Arn}"]}]
    DependsOn: AmazonBedrockExecutionRoleForKnowledgeBase

  OpenSearchVectorIndexLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import os
          import sys
          import subprocess
          import json
          import traceback
          import boto3
          import urllib3
          import logging
          import base64
          import time
          import random
          import string
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def install_and_import_dependencies():
              subprocess.check_call([sys.executable, "-m", "pip", "install", "--target", "/tmp", "requests", "requests_aws4auth"])
              sys.path.append('/tmp')
              global requests, AWS4Auth
              import requests
              from requests_aws4auth import AWS4Auth
              logger.info("Dependencies installed and imported successfully")

          def generate_policy_version():
              timestamp = int(time.time())
              random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
              version_string = f"{timestamp}-{random_string}"
              return base64.b64encode(version_string.encode()).decode().rstrip('=')

          def send_cfn_response(event, context, response_status, response_data, physical_resource_id=None, reason=None):
              response_url = event['ResponseURL']
              logger.info(f"CFN response URL: {response_url}")

              response_body = {
                  'Status': response_status,
                  'Reason': reason or f"See the details in CloudWatch Log Stream: {context.log_stream_name}",
                  'PhysicalResourceId': physical_resource_id or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'NoEcho': False,
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)
              logger.info(f"CFN response body: {json_response_body}")

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              try:
                  http = urllib3.PoolManager()
                  response = http.request('PUT', response_url, headers=headers, body=json_response_body)
                  logger.info(f"CFN response status code: {response.status}")
              except Exception as e:
                  logger.error(f"Error sending CFN response: {str(e)}")

          def handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              try:
                  install_and_import_dependencies()

                  region = os.environ['AWS_REGION']
                  service = 'aoss'
                  credentials = boto3.Session().get_credentials()
                  awsauth = AWS4Auth(credentials.access_key, credentials.secret_key, region, service, session_token=credentials.token)
                  
                  collection_name = event['ResourceProperties']['CollectionName']
                  index_name = event['ResourceProperties']['IndexName']
                  
                  client = boto3.client('opensearchserverless')
                  
                  logger.info(f"Attempting to get collection details for {collection_name}")
                  collection_data = client.batch_get_collection(names=[collection_name])['collectionDetails'][0]
                  collection_endpoint = collection_data['collectionEndpoint']
                  
                  logger.info(f"Collection endpoint: {collection_endpoint}")

                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      logger.info("Going to sleep")
                      time.sleep(120)
                      logger.info("Woke up")
                      create_vector_index(collection_endpoint, index_name, awsauth)
                      time.sleep(30)
                  elif event['RequestType'] == 'Delete':
                      delete_index(collection_endpoint, index_name, awsauth)

                  send_cfn_response(event, context, 'SUCCESS', {"message": "Operation completed successfully"})
              except Exception as e:
                  logger.error(f"Error occurred: {str(e)}")
                  logger.error(f"Traceback: {traceback.format_exc()}")
                  send_cfn_response(event, context, 'FAILED', {"error": str(e)})

          def create_vector_index(endpoint, index_name, awsauth):
              url = f'{endpoint}/{index_name}'
              
              index_body = {
                  "settings": {
                      "index.knn": True
                  },
                  "mappings": {
                      "properties": {
                          "vector": {
                              "type": "knn_vector",
                              "dimension": 1536,
                              "method": {
                                  "name": "hnsw",
                                  "space_type": "l2",
                                  "engine": "faiss"
                              }
                          }
                      }
                  }
              }

              headers = {"Content-Type": "application/json"}
              
              logger.info(f"Attempting to create index {index_name}")
              logger.info(f"Request URL: {url}")
              logger.info(f"Request body: {json.dumps(index_body)}")
              
              try:
                  response = requests.put(url, auth=awsauth, json=index_body, headers=headers)
                  logger.info(f"Index creation response status: {response.status_code}")
                  logger.info(f"Index creation response body: {response.text}")
                  response.raise_for_status()
              except requests.exceptions.RequestException as e:
                  logger.error(f"Request failed: {e}")
                  if hasattr(e, 'response'):
                      logger.error(f"Response status code: {e.response.status_code}")
                      logger.error(f"Response body: {e.response.text}")
                  raise

          def delete_index(endpoint, index_name, awsauth):
              url = f'{endpoint}/{index_name}'
              logger.info(f"Attempting to delete index {index_name}")
              logger.info(f"Request URL: {url}")
              try:
                  response = requests.delete(url, auth=awsauth)
                  logger.info(f"Index deletion response status: {response.status_code}")
                  logger.info(f"Index deletion response body: {response.text}")
                  if response.status_code != 404:  # Ignore 404 errors on delete
                      response.raise_for_status()
              except requests.exceptions.RequestException as e:
                  logger.error(f"Request failed: {e}")
                  if hasattr(e, 'response'):
                      logger.error(f"Response status code: {e.response.status_code}")
                      logger.error(f"Response body: {e.response.text}")
                  if response.status_code != 404:  # Ignore 404 errors on delete
                      raise
      Runtime: python3.8
      Timeout: 300
      MemorySize: 256

  AttachPolicyLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          import traceback
          import time
          import random
          import string
          import base64

          def generate_policy_version():
              timestamp = int(time.time())
              random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
              version_string = f"{timestamp}-{random_string}"
              return base64.b64encode(version_string.encode()).decode().rstrip('=')

          def handler(event, context):
              client = boto3.client('opensearchserverless')
              
              try:
                  print(f"Received event: {json.dumps(event)}")
                  
                  if event['RequestType'] in ['Create', 'Update']:
                      policy_name = 'instantagent-access-policy3'
                      collection_name = event['ResourceProperties']['CollectionName']
                      iam_role_arn = event['ResourceProperties']['IAMRoleArn']
                      kb_role_arn = event['ResourceProperties']['KBRoleArn']
                      user_role_arn = event['ResourceProperties']['IAMUserArn']

                      policy_version = generate_policy_version()
                      print(f"Generated policy version: {policy_version}")

                      print(f"IAM Role ARN: {iam_role_arn}")
                      existing_policy = client.get_access_policy(name=policy_name, type='data')
                      print(f"existing Policy content: {json.dumps(existing_policy)}")

                      latest_version = existing_policy['accessPolicyDetail']['policyVersion']

                      print(f"Latest policy version: {latest_version}")

                      policy = [{
                          "Rules": [{
                              "ResourceType": "collection",
                              "Resource": [f"collection/{collection_name}"],
                              "Permission": ["aoss:*"]
                          },
                          {
                              "ResourceType": "index",
                              "Resource": [f"index/{collection_name}/*"],
                              "Permission": [
                                "aoss:CreateIndex",
                                "aoss:UpdateIndex",
                                "aoss:DescribeIndex",
                                "aoss:ReadDocument",
                                "aoss:WriteDocument",
                                "aoss:*"
                            ]
                          }],
                          "Principal": [iam_role_arn,kb_role_arn,user_role_arn]
                      }]
                      
                      print(f"Updating policy: {policy_name}")
                      print(f"Policy content: {json.dumps(policy)}")
                      
                      response = client.update_access_policy(
                          name=policy_name,
                          type='data',
                          description='Updated by CloudFormation',
                          policy=json.dumps(policy),
                          policyVersion=latest_version
                      )
                      
                      print(f"Update policy response: {json.dumps(response)}")
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  print(f"Error: {str(e)}")
                  print(f"Traceback: {traceback.format_exc()}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {"Error": str(e)})
      Runtime: python3.8
      Timeout: 60
      MemorySize: 128

  VectorIndexUpdate:
    Type: Custom::OpenSearchServerlessVectorIndex
    Properties:
      ServiceToken: !GetAtt OpenSearchVectorIndexLambda.Arn
      CollectionName: !Ref AOSSCollectionName
      IndexName: !Ref AOSSIndexName
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    DependsOn: Collection

  OpenSearchServerlessCollectionPolicyAttachment:
    Type: Custom::OpenSearchServerlessCollectionPolicyAttachment
    Properties:
      ServiceToken: !GetAtt AttachPolicyLambda.Arn
      CollectionName: !Ref AOSSCollectionName
      PolicyName: !Ref DataAccessPolicy
      IAMRoleArn: !GetAtt LambdaExecutionRole.Arn
      KBRoleArn: !GetAtt AmazonBedrockExecutionRoleForKnowledgeBase.Arn
      IAMUserArn: !GetAtt AdminUser.Arn
    DependsOn: 
      - Collection
      - DataAccessPolicy

  AmazonBedrockExecutionRoleForAgentsQA5:
    Type: AWS::IAM::Role
    Properties:
      RoleName: AmazonBedrockExecutionRoleForAgents_QA5
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: bedrock.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess

  KnowledgeBaseWithAoss:
    Type: AWS::Bedrock::KnowledgeBase
    DependsOn: 
      - Collection
      - VectorIndexUpdate
    Properties:
      Name: !Ref KnowledgeBaseName
      Description: !Ref KnowledgeBaseDescription
      RoleArn: !GetAtt AmazonBedrockExecutionRoleForKnowledgeBase.Arn
      KnowledgeBaseConfiguration:
        Type: "VECTOR"
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub "arn:${AWS::Partition}:bedrock:${AWS::Region}::foundation-model/amazon.titan-embed-text-v1"
      StorageConfiguration:
        Type: "OPENSEARCH_SERVERLESS"
        OpensearchServerlessConfiguration:
          CollectionArn: !GetAtt Collection.Arn
          VectorIndexName: !Ref AOSSIndexName
          FieldMapping:
            VectorField: "vector"
            TextField: "text"
            MetadataField: "metadata"

  SampleDataSource:
    Type: AWS::Bedrock::DataSource
    DependsOn: KnowledgeBaseWithAoss
    Properties:
      KnowledgeBaseId: !Ref KnowledgeBaseWithAoss
      Name: !Ref S3Bucket
      DataSourceConfiguration:
        Type: "S3"
        S3Configuration:
          BucketArn: !GetAtt S3Bucket.Arn

  AgentResource:
    Type: AWS::Bedrock::Agent
    DependsOn: 
      - KnowledgeBaseWithAoss
      - AmazonBedrockExecutionRoleForAgentsQA5
    Properties:
      AgentName: !Ref AgentName
      AgentResourceRoleArn: !GetAtt AmazonBedrockExecutionRoleForAgentsQA5.Arn
      AutoPrepare: true
      FoundationModel: "amazon.titan-text-premier-v1:0"
      Instruction: "You are an HR bot tasked with matching candidates to suitable roles based on their skill sets, experience, and qualifications."
      Description: "AI Agent Bot powered by Amazon Bedrock"
      IdleSessionTTLInSeconds: 900
      KnowledgeBases:
        - KnowledgeBaseId: !Ref KnowledgeBaseWithAoss
          Description: !Ref KnowledgeBaseDescription
          KnowledgeBaseState: ENABLED

  BedrockAgentAlias:
    Type: 'AWS::Bedrock::AgentAlias'
    DependsOn: 
      - AgentResource
    Properties:
      AgentId: !Ref AgentResource
      AgentAliasName: 'prodalias'

  # IAM Role for Lambda (unchanged)
  AgentLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeAgent
                  - bedrock-agent-runtime:InvokeAgent
                Resource: '*'

  # Lambda Function (unchanged)
  LambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - AgentResource
      - BedrockAgentAlias
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt AgentLambdaExecutionRole.Arn
      Environment:
        Variables:
          BEDROCK_AGENT_ID: !Ref AgentResource
          BEDROCK_ALIAS_ID: !GetAtt BedrockAgentAlias.AgentAliasId
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          from botocore.exceptions import ClientError
          import uuid
          import re

          # Set up logging
          logger = logging.getLogger()
          #logger.setLevel(logging.INFO)
          class BytesEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, bytes):
                      return obj.decode('utf-8', errors='replace')
                  return super().default(obj)

          def parseparam(event):
            try:
                message=''
                
                # Check if message is directly in event (test invoke)
                if isinstance(event, dict) and 'message' in event:
                    message = event['message']
                    
                # Check if message is in body (API Gateway POST)
                elif isinstance(event, dict) and 'body' in event:
                    # Handle string body
                    if isinstance(event['body'], str):
                        import json
                        body = json.loads(event['body'])
                    else:
                        body = event['body']
                        
                    message = body.get('message')
                    
                    return message
                    
                else:
                    return ""
                    
                # Process message here
                return message
                
            except Exception as e:
                return ""

          def extract_result_from_raw_response(raw_response):
              print(f"Attempting to extract result from: {raw_response}")  # Debug print
              
              try:
                  # First attempt: try to find result between instruction and end
                  pattern = r'"result":\s*"(.*?)"}'
                  match = re.search(pattern, raw_response, re.DOTALL)
                  if match:
                      result = match.group(1)
                      print(f"Found result using first pattern: {result}")  # Debug print
                      return result
                      
                  # Second attempt: broader pattern
                  pattern = r'"result":\s*"([^}]*)'
                  match = re.search(pattern, raw_response, re.DOTALL)
                  if match:
                      result = match.group(1)
                      print(f"Found result using second pattern: {result}")  # Debug print
                      # Clean up any trailing quotes or backslashes
                      result = result.rstrip('"\\ ')
                      return result
                      
                  # If both patterns fail, print for debugging
                  print("No match found with either pattern")
                  return None
                  
              except Exception as e:
                  print(f"Error in extract_result_from_raw_response: {e}")
                  return None
              
          def lambda_handler(event, context):
              client = boto3.client('bedrock-agent-runtime')
              AGENT_ID = os.environ['BEDROCK_AGENT_ID']
              ALIAS_ID = os.environ['BEDROCK_ALIAS_ID']
              
                  
              user_message = parseparam(event)
              session_id = str(uuid.uuid4())

              # Log the boto3 version
              try:
                  # Send the message to the Bedrock agent with additional parameters
                  response = client.invoke_agent(
                      agentId=AGENT_ID, #'CYQACSRTBT',
                      agentAliasId=ALIAS_ID, 
                      sessionId='1234567',
                      inputText=user_message,
                      enableTrace=True
                  )
                  
                  enable_trace=True
                  # Process the event stream response
                  full_response = ""
                  
                  for event_dict in response['completion']:
                      # Handle chunk events which contain the actual response
                      if 'chunk' in event_dict:
                          chunk = event_dict['chunk']
                          if 'bytes' in chunk:
                              try:
                                  print(f"Chunk data: {chunk['bytes'].decode('utf-8')}")
                                  # Parse the bytes content as JSON
                                  
                                  chunk_data = json.loads(chunk['bytes'].decode('utf-8'))

                                  if 'result' in chunk_data:
                                      print(f"Found result: {chunk_data['result']}")
                                      full_response += chunk_data['result']
                              except json.JSONDecodeError:
                                  # If not JSON, just decode the bytes directly
                                  print(f"Not JSON event: {chunk['bytes'].decode('utf-8')}")
                  
                                  full_response += extract_result_from_raw_response(chunk['bytes'].decode('utf-8'))
                                  
                      # Print trace events for debugging
                      elif 'trace' in event_dict:
                          print(f"Trace event: {json.dumps(event_dict['trace'])}")
                  
                      
                  if not full_response:
                      full_response = "Unable to process response. Please check CloudWatch logs."
                      
                  full_response = full_response.strip()
                  full_response = full_response.replace('\n', '<br>')
                  
                  result = {
                      'message': 'Successfully sent message to Bedrock agent',
                      'result': full_response,
                  }
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(result),
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                          'Access-Control-Allow-Methods': 'GET,POST,OPTIONS'
                      }
                  }
              except ClientError as e:
                  logger.error(f"Bedrock Agent ClientError: {e}")
                  return {
                      'statusCode': 400,
                      'body': json.dumps({
                          'message': 'Error invoking Bedrock agent',
                          'error': str(e)
                      }, cls=BytesEncoder),
                      'headers': {
                          'Access-Control-Allow-Origin': '*'
                      }
                  }
              except Exception as e:
                  logger.error(f"Unexpected error: {e}")
                  logger.error(f"Event: {event}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': 'Unexpected error when sending message to Bedrock agent',
                          'error': str(e),
                          'event': event
                      }, cls=BytesEncoder),
                      'headers': {
                          'Access-Control-Allow-Origin': '*'
                      }
                  }

      Runtime: python3.9
      Timeout: 30
      MemorySize: 128

  # API Gateway REST API
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: BedrockAgentAPI
      Description: API Gateway for Bedrock Agent Lambda function
      EndpointConfiguration:
        Types:
          - REGIONAL

  # Proxy Resource to handle all paths
  ProxyResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: chat

  # Proxy ANY Method
  ProxyMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ProxyResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt LambdaFunction.Arn
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ####
  OptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: OPTIONS
      ResourceId: !Ref ProxyResource
      RestApiId: !Ref ApiGateway
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ProxyMethod
      - OptionsMethod
    Properties:
      RestApiId: !Ref ApiGateway

  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      DeploymentId: !Ref ApiDeployment
      RestApiId: !Ref ApiGateway
      StageName: prod

  

  # Lambda Permission for API Gateway
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt LambdaFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*/*

  # S3 Bucket Cleanup Function
  S3CleanupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3CleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:DeleteObject
                  - s3:DeleteObjectVersion
                  - s3:GetObjectVersion
                  - s3:ListBucketVersions
                Resource: 
                  - !Sub 'arn:aws:s3:::${PrivateS3Bucket}'
                  - !Sub 'arn:aws:s3:::${PrivateS3Bucket}/*'
                  - !Sub 'arn:aws:s3:::${S3Bucket}'
                  - !Sub 'arn:aws:s3:::${S3Bucket}/*'

  S3CleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt S3CleanupRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def delete_bucket_contents(bucket_name):
              try:
                  logger.info(f"Starting cleanup of bucket: {bucket_name}")
                  s3 = boto3.client('s3')
                  
                  # Delete all object versions
                  paginator = s3.get_paginator('list_object_versions')
                  pages = paginator.paginate(Bucket=bucket_name)
                  
                  delete_list = []
                  
                  try:
                      for page in pages:
                          # Handle versions
                          if 'Versions' in page:
                              for version in page['Versions']:
                                  delete_list.append({
                                      'Key': version['Key'],
                                      'VersionId': version['VersionId']
                                  })
                          
                          # Handle delete markers
                          if 'DeleteMarkers' in page:
                              for marker in page['DeleteMarkers']:
                                  delete_list.append({
                                      'Key': marker['Key'],
                                      'VersionId': marker['VersionId']
                                  })
                          
                          if delete_list:
                              logger.info(f"Deleting {len(delete_list)} objects")
                              s3.delete_objects(
                                  Bucket=bucket_name,
                                  Delete={'Objects': delete_list}
                              )
                              delete_list = []
                      
                      # Final check for non-versioned objects
                      paginator = s3.get_paginator('list_objects_v2')
                      pages = paginator.paginate(Bucket=bucket_name)
                      
                      for page in pages:
                          if 'Contents' in page:
                              objects = [{'Key': obj['Key']} for obj in page['Contents']]
                              if objects:
                                  logger.info(f"Deleting {len(objects)} non-versioned objects")
                                  s3.delete_objects(
                                      Bucket=bucket_name,
                                      Delete={'Objects': objects}
                                  )
                      
                      logger.info(f"Successfully cleaned up bucket: {bucket_name}")
                      return True
                      
                  except Exception as e:
                      logger.error(f"Error during deletion: {str(e)}")
                      return False
                      
              except Exception as e:
                  logger.error(f"Error accessing bucket: {str(e)}")
                  return False

          def handler(event, context):
              logger.info('Received event: %s', event)
              response_data = {}
              
              try:
                  bucket_name = event['ResourceProperties']['BucketName']
                  
                  if event['RequestType'] == 'Delete':
                      # Attempt cleanup multiple times
                      max_attempts = 3
                      for attempt in range(max_attempts):
                          logger.info(f"Cleanup attempt {attempt + 1} of {max_attempts}")
                          if delete_bucket_contents(bucket_name):
                              break
                          if attempt < max_attempts - 1:
                              time.sleep(5)  # Wait before retry
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
              except Exception as e:
                  logger.error(f"Error in handler: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

      Runtime: python3.9
      Timeout: 300  # Increased timeout to 5 minutes
      MemorySize: 256  # Increased memory

  PrivateS3Bucket:
    Type: 'AWS::S3::Bucket'
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: 'AES256'
      VersioningConfiguration:
        Status: Enabled

  BucketCleanupResource:
    Type: Custom::S3Cleanup
    DependsOn: PrivateS3Bucket
    Properties:
      ServiceToken: !GetAtt S3CleanupFunction.Arn
      BucketName: !Ref PrivateS3Bucket


  BucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref PrivateS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: DenyUnsecuredTransport
            Effect: Deny
            Principal: '*'
            Action: 's3:*'
            Resource: 
              - !Sub '${PrivateS3Bucket.Arn}/*'
              - !GetAtt PrivateS3Bucket.Arn
            Condition:
              Bool:
                'aws:SecureTransport': false

  S3UploaderRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3UploadAndSignPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource: !Sub '${PrivateS3Bucket.Arn}/*'

  S3UploaderFunction:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - ApiGateway
      - ApiStage
    Properties:
      Handler: index.handler
      Role: !GetAtt S3UploaderRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          
          def handler(event, context):
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      s3 = boto3.client('s3')
                      bucket_name = event['ResourceProperties']['BucketName']
                      api_gateway = event['ResourceProperties']['ApiGateway']
                      aws_region = event['ResourceProperties']['AWSReg']
                      
                      # HTML content
                      html_content = """
                      <!DOCTYPE html>
                        <html>
                        <head>
                            <title>Chat with your documents</title>
                            <style>
                                body { 
                                    font-family: Arial, sans-serif; 
                                    max-width: 800px; 
                                    margin: 0 auto; 
                                    padding: 20px;
                                    background-color: #f5f5f5;
                                }
                                #chat-container { 
                                    height: 500px; 
                                    overflow-y: auto; 
                                    border: 1px solid #ddd; 
                                    padding: 20px;
                                    background-color: white;
                                    border-radius: 8px;
                                    margin-bottom: 20px;
                                }
                                #input-container { 
                                    display: flex; 
                                    gap: 10px;
                                    margin-bottom: 20px;
                                }
                                #message-input { 
                                    flex-grow: 1; 
                                    padding: 10px;
                                    border: 1px solid #ddd;
                                    border-radius: 4px;
                                    font-size: 16px;
                                }
                                button {
                                    padding: 10px 20px;
                                    background-color: #007bff;
                                    color: white;
                                    border: none;
                                    border-radius: 4px;
                                    cursor: pointer;
                                }
                                button:hover {
                                    background-color: #0056b3;
                                }
                                .message {
                                    margin-bottom: 15px;
                                    padding: 10px;
                                    border-radius: 4px;
                                    max-width: 80%;
                                }
                                .user-message {
                                    background-color: #007bff;
                                    color: white;
                                    margin-left: auto;
                                }
                                .assistant-message {
                                    background-color: #e9ecef;
                                    color: black;
                                }
                                #loading {
                                    display: none;
                                    text-align: center;
                                    color: #666;
                                    padding: 10px;
                                }
                            </style>
                        </head>
                        <body>
                            <h1>Bedrock Chat</h1>
                            <div id="chat-container"></div>
                            <div id="loading">Assistant is typing...</div>
                            <div id="input-container">
                                <input type="text" id="message-input" placeholder="Type your message...">
                                <button onclick="sendMessage()">Send</button>
                            </div>
                            <script>
                                const apiUrl = 'AAAAA.execute-api.RRRR.amazonaws.com/prod/chat';
                                const messageInput = document.getElementById('message-input');
                                const chatContainer = document.getElementById('chat-container');
                                const loadingIndicator = document.getElementById('loading');
                                
                                messageInput.addEventListener('keypress', function(e) {
                                    if (e.key === 'Enter') {
                                        sendMessage();
                                    }
                                });
                                
                                async function sendMessage() {
                                    const message = messageInput.value.trim();
                                    if (!message) return;
                                    
                                    messageInput.value = '';
                                    appendMessageToChat(message, 'user');
                                    loadingIndicator.style.display = 'block';
                                    
                                    try {
                                        const response = await fetch('https://' + apiUrl, {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({ message: message })
                                        });
                                        
                                        const cleanJSON = await response.json();

                                        loadingIndicator.style.display = 'none';
                                        appendMessageToChat(cleanJSON['result'], 'assistant');
                                    } catch (error) {
                                        console.error('Error:', error);
                                        loadingIndicator.style.display = 'none';
                                        appendMessageToChat('Error: Failed to get response', 'assistant');
                                    }
                                }
                                
                                function appendMessageToChat(messageText, senderType) {
                                    const messageElement = document.createElement('div');
                                    messageElement.className = 'message ' + senderType + '-message';
                                    messageElement.textContent = messageText;
                                    chatContainer.appendChild(messageElement);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                }
                            </script>
                        </body>
                        </html>
                      """
                      
                      html_content = html_content.replace('AAAAA', api_gateway)
                      html_content = html_content.replace('RRRR', aws_region)

                      # Upload the HTML file
                      s3.put_object(
                          Bucket=bucket_name,
                          Key='index.html',
                          Body=html_content,
                          ContentType='text/html'
                      )
                      
                      # Generate presigned URL (valid for 7 days - maximum allowed)
                      presigned_url = s3.generate_presigned_url(
                          'get_object',
                          Params={
                              'Bucket': bucket_name,
                              'Key': 'index.html'
                          },
                          ExpiresIn=604800  # 7 days in seconds
                      )
                      
                      responseData = {
                          'SignedURL': presigned_url
                      }
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
                  except Exception as e:
                      print(f"Error: {str(e)}")
                      cfnresponse.send(event, context, cfnresponse.FAILED, {})
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Runtime: python3.9
      Timeout: 30

  UploadHTMLAndGenerateURL:
    Type: 'Custom::S3Upload'
    Properties:
      ServiceToken: !GetAtt S3UploaderFunction.Arn
      BucketName: !Ref PrivateS3Bucket
      ApiGateway: !Ref ApiGateway
      AWSReg: !Ref AWS::Region

Outputs:
  S3Bucket:
    Value: !GetAtt S3Bucket.Arn
  S3BucketName:
    Value: !Ref S3Bucket
  S3BucketLink:
    Description: 'Link to the created S3 bucket'
    Value: !Sub https://s3.console.aws.amazon.com/s3/buckets/${S3Bucket}
  DashboardURL:
    Value: !GetAtt Collection.DashboardEndpoint
  AmazonBedrockExecutionRoleForKnowledgeBase:
    Value: !GetAtt AmazonBedrockExecutionRoleForKnowledgeBase.Arn
  CollectionARN:
    Value: !GetAtt Collection.Arn
  AOSSVectorIndexName:
    Description: vector index
    Value: !Ref AOSSIndexName
  Region:
    Description: Deployed Region
    Value: !Ref AWS::Region
  KnowledgeBaseId:
    Description: ID of the created Knowledge Base
    Value: !Ref KnowledgeBaseWithAoss
  AgentId:
    Description: ID of the created Agent
    Value: !Ref AgentResource
  AgentRoleArn:
    Description: ARN of the Agent execution role
    Value: !GetAtt AmazonBedrockExecutionRoleForAgentsQA5.Arn
  LambdaExecutionRoleArn:
    Description: ARN of the Lambda execution role
    Value: !GetAtt LambdaExecutionRole.Arn
  LambdaFunctionName:
    Description: Name of the Lambda function
    Value: !Ref LambdaFunction
  BackendURL:
    Description: 'API Gateway endpoint URL for prod stage'
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod/chat
  FrontendURL:
    Description: 'Presigned URL for accessing the HTML file (valid for 7 days)'
    Value: !GetAtt UploadHTMLAndGenerateURL.SignedURL
